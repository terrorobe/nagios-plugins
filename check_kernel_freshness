#!/usr/bin/perl

# Author: Michael Renner <michael.renner@amd.co.at>

# License: MIT

# This module checks if the current running Linux kernel matches the installed one.
# See the documentation at the end of the file or use --help

use constant VERSION => '1.0.1';

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Carp;

my $help;
my $kernel_image;
my $no_heuristic;
my $no_grub;
my $long_help;
my $print_version;

GetOptions(
    'help|h'           => \$help,
    'long-help'        => \$long_help,
    'kernel-image|k:s' => \$kernel_image,
    'no-heuristic'     => \$no_heuristic,
    'no-grub'          => \$no_grub,
    'version|v'        => \$print_version,
) or pod2usage( -verbose => 0 );

pod2usage( -verbose => 1 ) if ($help);
pod2usage( -verbose => 2 ) if ($long_help);

if ($print_version) {
	print "check_kernel_freshness " . VERSION . "\n";
	exit 0;
}

# eg:
# Linux version 2.6.30-bpo.2-amd64 (Debian 2.6.30-7~bpo50+1) (nobse@debian.org) (gcc version 4.3.2 (Debian 4.3.2-1.1) ) #1 SMP Fri Sep 18 11:50:10 UTC 2009
# Linux version 2.6.32-042stab083.2 (root@rh6-build-x64) (gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) ) #1 SMP Fri Nov 8 18:08:40 MSK 2013
# Linux version 3.11-0.bpo.2-amd64 (debian-kernel@lists.debian.org) (gcc version 4.6.3 (Debian 4.6.3-14) ) #1 SMP Debian 3.11.8-1~bpo70+1 (2013-11-21)
# Linux version 3.2.0-4-amd64 (debian-kernel@lists.debian.org) (gcc version 4.6.3 (Debian 4.6.3-14) ) #1 SMP Debian 3.2.57-3+deb7u2

my $versionRE = qr!
    ^                       # Line Begin Anchor
    (?:Linux\sversion\s)?   # Optional prefix found in /proc/version
    (\d+\.\d+\S+)           # Kernel Version
    .*                      # Match as much as possible
    (                       # Start build block
    \#\d+                   # Start with the build number
    .*                      # Match anything
    (?:
    20\d{2}                 # Finish with the year, not year 2100 compliant.
    |                       # OR
    (?:\d+\.\d+\.\d+\S+\s*) # Kernel Version
    )
    (?:\(\d+-\d+-\d+\))?    # Optional Build Date
    )                       # End build block
    $                       # Line end anchor
!x;

my ( $running_version, $running_build ) = fetch_running_version();
my ( $filename, $image_version, $image_build ) = fetch_image_version($kernel_image);
my $grub_kernelversion = fetch_grub_default();

# Include real filename if target is a symlink
$filename .= ' -> ' . readlink($filename) if ( -l $filename );

if ($grub_kernelversion) {
    if ( $grub_kernelversion ne $running_version ) {
        print
"WARNING: Version mismatch between running ($running_version) and GRUB default ($grub_kernelversion)\n";
        exit 1;
    }

    print
"OK: Running Kernel ($running_version $running_build) matches GRUB default ($grub_kernelversion)\n";
    exit 0;
}

if ( $running_version ne $image_version ) {
    print
"WARNING: Version mismatch between running ($running_version) and installed $filename ($image_version) kernel\n";
    exit 1;
}

if ( $running_build ne $image_build ) {
    print
"WARNING: Build mismatch between $image_version kernels. Running: $running_build, installed ($filename): $image_build\n";
    exit 1;
}

print
"OK: Running Kernel ($running_version $running_build) matches installed version ($filename)\n";
exit 0;

########
# Subs #
########

sub fetch_running_version {

    open( my $fh, '<', '/proc/version' ) or croak "Can't open $filename: $!";

    my $version_line = <$fh>;
    chomp($version_line);

    close($fh) or croak "Can't close $filename: $!";

    my ( $running_version, $running_build ) = $version_line =~ m/$versionRE/;

    croak "Didn't get a version line out of /proc/version"
      unless $running_version;

    return $running_version, $running_build;
}

sub fetch_image_version {

    my ($filename) = @_;

    $filename = get_kernel_image_filename() unless ($filename);

    my $image_version;
    my $image_build;

    open( my $fh, '<', $filename ) or croak "Can't open $filename: $!";

    my $chunksize = 4096;
    my $string;
    my $buf;

    while ( $buf or read( $fh, $buf, $chunksize ) ) {
        $string = '';

        # Strip unprintable characters from beginning of buf
        $buf =~ s/^([^[:print:]])//;

# Copy printable characters from beginning of buf to string
# Tries to read again if buf is empty, since the string could continue in the next chunk
# Stops when buf still contains stuff (which is non-printable) or read doesn't return anything
        do {
            $string .= $1 if $buf =~ s/^([[:print:]]+)//;
        } until ( $buf || !read( $fh, $buf, $chunksize ) );

        # Longer than at least
        # #1 SMP Fri Sep 18 11:50:10 UTC 2009

        if ( length($string) >= 40 && $string =~ m/$versionRE/ ) {
            $image_version = $1;
            $image_build   = $2;
            last;
        }
    }
    close $fh or croak "Can't close $filename: $!";

    croak "Didn't get a version line out of $filename" unless $image_version;

    return $filename, $image_version, $image_build;
}

sub get_kernel_image_filename {

    my $filename;

    # First, see if either /vmlinuz or /boot/vmlinuz exist

    for my $prefix (qw( / /boot/)) {
        if ( -e $prefix . 'vmlinuz' ) {
            $filename = $prefix . 'vmlinuz';
            return $filename;
        }
    }

    # If this wasn't successfull and heuristic mode is enabled, widen our search
    unless ($no_heuristic) {
        $filename = find_kernel_image();
        if ($filename) {
            return $filename;
        }
        else {
            croak
"Heuristic couldn't find a kernel image matching /vmlinuz* or /boot/vmlinuz*\n";
        }
    }

    # If we're here, we've failed.
    croak
"Couldn't find a kernelimage at /vmlinuz and /boot/vmlinuz. Please either supply one or use the heuristic mode\n";
}

sub find_kernel_image {

    # We're looking for files and symlinks named vmlinuz at / and /boot
    for my $directory (qw( / /boot/)) {
        my @entries = glob "$directory" . 'vmlinuz*';

        my ( @symlinks, @files );

        for my $entry (@entries) {
            push @symlinks, $entry if ( -l $entry );
            push @files,    $entry if ( -f $entry );
        }

        # Return the _SHORTEST_ symlink
        if (@symlinks) {
            return ( sort { length($a) <=> length($b) } @symlinks )[0];
        }

   # If no suitable symlink exist - return the kernel with the "highest" version
        if (@entries) {
            return ( reverse sort { sort_versionstring() } @entries )[0];
        }
    }
    return;
}

# FIXME: This only works for "number"-based default entries
sub fetch_grub_default {
	return if $no_grub;

    my @candidates = qw( /boot/grub/grub.cfg /boot/grub/grub.conf );
    my $path;
    for my $candidate (@candidates) {
        if ( -f $candidate && -r $candidate ) {
            $path = $candidate;
            last;
        }
    }
    return unless $path;

    open( my $fh, '<', $path ) or croak "Can't open $path: $!";
    my @grub_config = <$fh>;
    close($fh) or croak "Can't close $path: $!";

    my @grub_entries;

    # Defaults to first entry if not present
    my $grub_default = 0;

    for my $grub_line (@grub_config) {
        if ( $grub_line =~ qr/(?:kernel|linux).*?(\d+\.\d+\S+)/ ) {
            push( @grub_entries, $1 );
            next;
        }

        if ( $grub_line =~ qr/set\s*default\s*=\s*"?(\d+)"?/ ) {
            $grub_default = $1;
            next;
        }
    }

    return $grub_entries[$grub_default];
}

sub sort_versionstring {

# Sorts given filenames from lowest to highest version number
# If it fails to parse a given version number it puts the file before the smallest parseable file

    my $filenameRE = qr/vmlinuz.*?(\d+\.\d+\.\d+)/;

    my ($version_a) = $a =~ m/$filenameRE/;
    my ($version_b) = $b =~ m/$filenameRE/;

    return -1 unless ( defined $version_a );
    return 1  unless ( defined $version_b );

    my @elems_a = split /\./, $version_a;
    my @elems_b = split /\./, $version_b;

    croak "Uneven number of version parts in $a, $b\n"
      unless ( @elems_a == @elems_b );

    for my $elem ( 0 .. $#elems_a ) {
        my $result = $elems_a[$elem] <=> $elems_b[$elem];

# We only want to return if one of the version part pairs differ from each other (i.e. "not 0")
        return $result if ($result);
    }

    return 0;
}

__END__

=head1 NAME

check_kernel_freshness - A Nagios plugin to check if a given Linux system is running the installed kernel


=head1 SYNOPSIS

check_kernel_freshness [ -k --kernel-image filename ] [ --no-heuristic ] [ --no-grub ]


   Options:
  -k, --kernel-image    Filename of the kernel image to check (default: /vmlinuz, /boot/vmlinuz)
      --no-heuristic    Disable heuristic to search for a kernel image filename
      --no-grub         Disable GRUB config file parsing
  -h, --help            Show documentation
      --long-help       Show long documentation (needs perldoc)
  -v, --version         Print version and exit


=head1 OPTIONS

=over 8

=item B<--kernel-image>

Filename of the kernel image to check.

B<Default>: /vmlinuz, /boot/vmlinuz

=item B<--no-heuristic>

Disables heuristic to search for a kernel image filename.

When enabled, the plugin will search first / and then /boot for

=over

=item *) A symlink whose name starts with vmlinuz.

If multiple symlinks are found, the symlink with the shortest name is used

=item *) A file whose name starts with vmlinuz.

If multiple files are found, the list is sorted by version strings and the filename with the highest version is used

=back

The first matching occurance is then used.

=item B<--no-grub>

Disables parsing of GRUB config files.

By default, the files B</etc/grub/grub.cfg> and B</etc/grub/grub.conf> are tested for existance and the first file
that is found and readable will be analyzed.

In the grub config parsing mode, the kernel version strings are not gathered from the kernel image itself, but only
from it's filename.


=back

=head1 DESCRIPTION

B<check_kernel_freshness> is a monitoring plugin which checks if the running kernel matches the version of the installed kernel.

This is useful to see if a server needs to be rebooted after a kernel upgrade.

=head2 Modus operandi

This plugin compares kernel version and build timestamp gathered from /proc/version with a string containing similiar information in a given kernel image. If kernel version or timestamp shouldn't match, a warning is raised.

=cut
